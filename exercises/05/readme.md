# Exercise 5 - Create extensions to get Additional Services

## Introduction - Scenario
In this exercise 5, you will learn how to add an Addon to your Kyma cluster. 
We will show you how to do this with a Redis Addon. 
With the add-on installed to your Kyma cluster, we will provide an instance of the Redis service. 
The Redis service instance will be bound to our previous Serverless function created, the numbers-generator-service. 
It will store the numbers generated by each call,  persisting it on the Redis instance, create a history that can be consumed via service later.

The main goal is to create an extension on Kyma and get additional services consumed by our previously lambda created.

### You Will Learn How to: 

- Add an Addon for Redis to the Catalog of the *project: "Kyma"*
- Create a new instance of the Addon 
- Bind the instance of the Redis Addon to the Serverless function
- Consume redis service to add and read keys inside the lambda

## Steps

### Create new deployment file for our AddOn

For this exercise, we will continue to use the project number-generator-service to store our kyma deployment files.
Let's create our new yaml in the src folder, containing the new addon definition file! - Use your CLI to navigate to the project base and create a file called *redisaddon.yaml*:

```
touch redisaddon.yaml
```

1. vim redisaddon.yaml
2. select the **i** key to insert a new line at the top of the file.
3. Add the following content to the file

```yaml 
apiVersion: addons.kyma-project.io/v1alpha1
kind: AddonsConfiguration
metadata:
  name: redis-addon
  namespace: devktoberfest
spec:
  reprocessRequest: 0
  repositories:
    - url: https://github.com/kyma-project/addons/releases/download/0.12.0/index-testing.yaml
```

4. Type ```:wq``` and select the Enter key to save the changes.

In the metadata section above, we are defining a new AddonsConfiguration object to kyma.
* We have defined the name as *redis-addon* into the devktoberfest namespace
* The definition of the redis service and provisioning is defined by the repositories tag, inside the spec, it is referring to the URL where the file index-testing.yaml file exists. 

5. To deploy our new addon, let's use kubectl command as following:

```
kubectl apply -f redisaddon.yaml -n devktoberfest
```

Don't forget to inform the namespace when you are applying the file. If you do not define the namespace in the kubectl command, it will take the definition from the yaml file, and if it's not defined either, then it will deploy your objects into the "default" namespace.
To check the status of Addon deployment type the following command:

```
kubectl get addons redis-addon -n devktoberfest -o=jsonpath="{.status.phase}"
```

The *status.phase* must be equal to *Ready* to start to use.
No, we have added to our AddOn catalog, an offer of a Redis service.
To be able to use the service we need to create a new Service Instance of the addon and binding it to our lambda services.

Open the Kyma Console UI and go to the Menu Catalog -> AddOns, then you can see the Redis offer as the image below:

![kyma-runtime-virtual-event-05-01](kyma-runtime-virtual-event-05-01.png)

### Create new Redis database instance

Let's create our new Redis service instance.

Edit our redisaddon.yaml file, and append the following metadata to the bottom of the service.

1. vim redisaddon.yaml
2. Go to the bottom of the file
3. select the **i** key to insert a new line at the top of the file.
4. Add the following content to the end of the file

```yaml
---
apiVersion: servicecatalog.k8s.io/v1beta1
kind: ServiceInstance
metadata:
  name: numbers-redis-service
  namespace: devktoberfest
spec:
  serviceClassExternalName: redis
  servicePlanExternalName: micro
  parameters:
    imagePullPolicy: Always
``` 

A Service Instance of our addon was defined with the name number-redis-service inside the devktoberfest namespace.
With this spec section we have to Kyma, that our Redis instance will use the *micro* service plan, that means that is a in-memory persistence. 

> The name of the service can be whatever you want, but it makes sense to give it a name which represents what it is.   

5. Type ```:wq``` and select the Enter key to save the changes.

> Remember that we need to use *---* line as a separator between the objects declaration inside the yaml file

6. Deploy the service instance to Kyma using the following command: 
 
```
 kubectl apply -f redisaddon.yaml -n devktoberfest
 ```

7. You can see the following output on the deployment

TODO: 
````shell script

````

8. Check the status of the service instance provisioning. This process can take more time, as it needs to download the image and configure everything.
Type the command

````shell script
kubectl get serviceinstance numbers-redis-service -n devktoberfest -o=jsonpath="{range .status.conditions[*]}{.type}{'\t'}{.status}{'\n'}{end}"
````

The last condition to the resource status is "Ready equals True".
If it is not ready yet, wait more seconds and execute the command again.

Open the Kyma Console UI and go to the Menu Instance -> AddOns, then you can see the Redis instance created as the image below:

![kyma-runtime-virtual-event-05-01](kyma-runtime-virtual-event-05-01.png)


### Create Service Bind to the Redis Service

After the provisioning of a new Redis instance service, is needed to have a ServiceBinding Kyma object, that is 
responsible to bound this Redis instance with any other services that you have created.

Edit our redisaddon.yaml file, and append the following metadata to the bottom of the service.

1. vim redisaddon.yaml
2. Go to the bottom of the file
3. select the **i** key to insert a new line at the top of the file.
4. Add the following content to the end of the file

```yaml
---
apiVersion: servicecatalog.k8s.io/v1beta1
kind: ServiceBinding
metadata:
  name: numbers-redis-servicebinding
  namespace: devktoberfest
spec:
  instanceRef:
    name: numbers-redis-service
``` 
5. Type ```:wq``` and select the Enter key to save the changes.

6. Deploy the service binding to Kyma using the following command: 
 
```
 kubectl apply -f redisaddon.yaml -n devktoberfest
```

This deployment descriptor, create a new object of kind ServiceBinding.
The metadata section, defined the name of the object as *number-redis-servicebinding*. 
In the spec section, the instanceRef tag was referred with the name of the Redis Service that we have created before, *number-redis-service*


7. Check the status of creation of the servicebinding object, executing the following command:
 
```shell script
 kubectl get servicebinding numbers-redis-servicebinding -n devktoberfest -o=jsonpath="{range .status.conditions[*]}{.type}{'\t'}{.status}{'\n'}{end}"
```

This *kubectl get* command, has defined that the output will be in the json format, this can facilitate the process
of parsing the result using regular expression to filter the condition and status attributes.

The last condition in the status should be Ready equals True:

TODO://
````shell script

````

Great!! The ServiceBinding object is created .

### Create Service Bind Usage to the Redis Service

We have created the Service Binding object, that now is attached to the Redis Service instance, now is time to connect our lambda service with that Redis service instance.

1. vim redisaddon.yaml
2. Go to the bottom of the file
3. select the **i** key to insert a new line at the top of the file.
4. Add the following content to the end of the file

```yaml
---
apiVersion: servicecatalog.kyma-project.io/v1alpha1
kind: ServiceBindingUsage
metadata:
  name: numbers-redis-bindingfunction
  namespace: devktoberfest
spec:
  serviceBindingRef:
    name: numbers-redis-servicebinding
  usedBy:
    kind: serverless-function
    name: numbers-generator-service
  parameters:
    envPrefix:
      name: "REDIS_"
``` 
5. Type ```:wq``` and select the Enter key to save the changes.

6. Deploy the service binding usage to Kyma using the following command: 
 
```shell script
 kubectl apply -f redisaddon.yaml -n devktoberfest
```

7. Check the status of creation of the ServiceBindingUsage object, executing the following command:
 
```shell script
 kubectl get servicebindingusage numbers-redis-bindingfunction -n devktoberfest -o=jsonpath="{range .status.conditions[*]}{.type}{'\t'}{.status}{'\n'}{end}"
``` 

The last condition in the status should be Ready equals True:

8. Check the secret credentials created by the number-redis-servicebinding object with the following command:

```shell script
 kubectl get secret numbers-redis-servicebinding -n devktoberfest -o go-template='{{range $k,$v := .data}}{{printf "%s: " $k}}{{if not $v}}{{$v}}{{else}}{{$v | base64decode}}{{end}}{{"\n"}}{{end}}'
``` 

You will be able to see the following output as result:

TODO://
````shell script

````
 
Let's get deeper into details of the configuration

In the metadata section, *numbers-redis-bindingfunction* was set as the name of the Service Binding Usage object.
The spec.serviceBindingRef and spec.usedBy fields are required. spec.serviceBindingRef field has been configured with the name of ServiceBinding that you have just created,
and spec.usedBy is set to the function numbers-generator-service, our lambda that generates random numbers. 
The usageBy also has the kind property, which is set to kind: serverless-function.
This combination will make Kyma, which defines how Secrets(credentials to connect on redis-service), should be injected to your Function when creating a ServiceBinding.

We still have the spec.parameters.envPrefix.name field, that is optional, but we are adding the prefix as REDIS_ in this exercise,
it will add this prefix to all environment variables injected into the Secret into our Serverless function when creating a new ServiceBinding

Everything is OK!! You have created the ServiceBindingUsage object, now our numbers-generator-service lambda can use and consume the Redis instance.

#### Check configuration in the Kyma Console UI

Open the Kyma Console UI, and then click on the left side in the Functions menu.
Select the numbers-generator-service, and click on it to see how it is configured.

At the bottom of the function definition, you can see that Kyma has injected the Secret credentials to the lambda functions.
These variables, can be used in your lambda code, to connect to the Redis service, and consume the database. It's great to see how Kyma
can provide to us, this flexibility on the configurations, and the secured that services have, no plain text password is stored or showed.


![kyma-runtime-virtual-event-05-01](kyma-runtime-virtual-event-05-01.png)

This variables, can be used in your lambda code, to connect to the Redis service, and consume the database. It's great to see how Kyma
can provide to us, this flexibility on the configurations, and the secured that services has, no plan text password is stored or showed.

Now, we are good to go, and change our lambda to connect on Redis Service.
 
### Change the Numbers Generator Service to store the history 